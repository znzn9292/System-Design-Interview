'수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적인 과제이며, 지속적인 계량과 끝없는 개선이 요구되는 여정이다.
한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로 몇백만 사용자를 지원하는 시스템을 설계해 볼 것이다.'

## 10장. 알림 시스템 설계
- - -

알림 시스템은 단순히 모바일 푸시 알림에 한정되지 않고 SMS 메세지, 이메일 세 가지로 분류할 수 있다.

### 알림 유형별 지원

**IOS 푸시 알림**
IOS에서 푸시 알림을 보내기 위해서는 세 가지 컴토넌트가 필요하다.

<img src="https://velog.velcdn.com/images/znzn9292/post/9088fa92-8236-4a0c-adbb-3772e2b51810/image.png" width="60%" height="30%">

* 알림 제공자(Provider): 알림 요청을 만들어 애플 푸시 알림 서비스(APNS: Apple Push Notification Service)로 보내는 주체
  - 단말 토큰(Device Token): 알림 요청을 보내는 데 필요한 고유 식별자
  - 페이로드(Payload): 알림 내용을 담은 JSON 딕셔너리

* APNS: 애플이 제공하는 원격 서비스로 푸시 알림을 IOS 단말로 보내는 역할
* IOS 단말(IOS Device): 푸시 알림을 수신하는 사용자 단말

**안드로이드 푸시 알림**
안드로이드 푸시 알림은 APNS 대신 FCM을 사용한다.

<img src="https://velog.velcdn.com/images/znzn9292/post/8755bafb-3163-45d1-9724-64d0aefd0c65/image.png" width="60%" height="30%">


**SMS 메세지**
SMS 메세지를 보낼 때는 보통 트윌리오(Twilio), 넥스모(Nexmo) 같은 제3사업자의 서비스를 많이 이용한다.

**이메일**
대부분의 회사는 고유 이메일 서버를 구축해 사용하지만 상용 이메일 서비스도 많이 이용한다.

### 연락처 정보 수집
알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등 정보가 필요하다.
사용자가 처음으로 계정을 등록하면 해당 사용자의 정보를 수집하여 데이터베이스에 저장한다.

<img src="https://velog.velcdn.com/images/znzn9292/post/379f9d5f-5915-421c-9786-f191d290f90c/image.png" width="60%" height="30%">

* 이메일 주소와 전화번호는 `USER` 테이블에 저장하고, 단말 데이터는 `DEVICE` 테이블에 저장한다.
* 한 사용자가 여러 단말을 가질 수 있고, 알림은 모든 단말에 전송되어야 한다.

### 알림 전송 및 수신 절차
<img src="https://velog.velcdn.com/images/znzn9292/post/fa32752e-ca75-46b4-9602-34912dca1471/image.png" width="60%" height="30%">

* 1부터 N까지의 서비스: 이 서비스는 각각은 마이크로 서비스, 크론잡 또는 분산 시스템 컴포넌트 등 알림을 요청하는 주체
* 알림 시스템: 알림 전송/수신 처리의 핵심이며, 각 서비스를 위한 알림 API를 제공해야하고, 제3자 서비스에 전달할 페이로드가 필요
* 제3자 서비스: 이 서비스들은 사용자에게 알림을 실제로 전달하는 역할
> 제3자 서비스를 이용할 때 유의할 것은 확정성(extensibility) 이다.
> 상용되어진 서비스이기에 다른 서비스로 교체가 수월해야하므로 쉽게 서비스를 통합하거나 제거할 수 있어야 한다.

하지만, 이 설계에는 몇가지 문제가 있다.
* SPOF(Single-Point-Of-Failure): 알림 서비스 서버가 한 대라 장애가 생기면 전체 서비스 장애로 이어짐
* 규모 확장성: 한 대 서비스로 알림에 전반적은 처리를 담당하므로 DB, 캐시 등 중요 컴포넌트를 개별적으로 늘릴 방법이 없음
* 성능 병목: 한 대 서비스로 모든 것을 처리하면 사용자 트래픽이 많이 몰리면 시스템 과부하 발생

### 개략적 설계안
<img src="https://velog.velcdn.com/images/znzn9292/post/27d06399-a46f-400a-b371-44dcab5312ab/image.png" width="60%" height="30%">

* 데이터베이스와 캐시를 알림 서버에서 분리
* 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이루어질 수 있도록 함
* 메세지 큐를 이용해 컴포넌트 사이의 강한 결합을 끊음
* 알림 서버 기능 변경

  - 사내 서비스 또는 인증된 클라이언트만 이용
  - 이메일 주소, 전화번호 등 기본적 검증
  - 데이터베이스 또는 캐시 질의
  - 알림 데이터를 메세지 큐 전달

* 캐시에는 사용자, 단말 정보, 알림 템플릿 등을 캐시
* 메세지 큐는 시스템 컴포넌트 간 의존성을 제거하여 알람 종류에 따라 독립적으로 동작
* 작업 서버는 메세지 큐에서 알림 데이터를 처리하고 제3자 서비스로 전달하는 역할

```sql
1. API를 호출하여 알림 서버로 알림을 보낸다
2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져온다.
3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어서 해당 이벤트를 위 한 큐에 넣는다. 
4. 작업 서버는 메세지 큐에서 알림 이벤트를 꺼낸다.
5. 작업 서버는 알림을 제3자 서비스로 보낸다.
6. 제3자 서비스는 사용자 단말로 알림을 전송한다.
```

### 안정성
분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보하기 위해 몇 가지 사항을 고려해야 한다.

**데이터 손실 방지**
알림 전송 시스템의 가장 중요한 요구사항은 알림이 소실되면 안되는 것이다.
이 요구사항을 만족하려면 알림 데이터를 데이터베이스에 보관하고 재시도 메커니즘을 구현해야 한다.

<img src="https://velog.velcdn.com/images/znzn9292/post/58bf3c04-ed35-4f13-a95a-7328ce04ed50/image.png" width="60%" height="30%">

**알림 중복 전송 방지**
분산 시스템 특성상 같은 알림이 중복되어 전송되기도 한다. 그 빈도를 줄이려면 중복을 탐지하는 메커니즘을 도입하고,
오류를 신중하게 처리해야 한다.
예를들어 보내려는 알림의 이벤트 ID를 검사하여 이 전에 발송 이력이 있는 이벤트인지 살핀다면 중복 전송을 방지 할 수 있을 것이다.

### 추가로 필요한 컴포넌트 및 고려사항

**알림 템플릿**
인자(parameter)나 스타일, 추적 링크를 사전에 지정한 형식에 맞춰 알람을 만들어 내는 틀
```sql
본문:
여러분이 꿈꿔온 그 상품을 우리가 준비했습니다. [item_name]이 다시 입고 되었습니다! [date]까지만 주만 가능합니다!

타이틀:
지금 [item_name]을 주문 또는 예약하세요!
```

* 템플릿을 사용하면 알림 형식의 일관성을 유지할수 있고, 알림 작성 시간도 줄임

**알림 설정**
사용자는 너무 많은 알림에 쉽게 피곤함을 느끼기에 웹사이트 또는 앱에서 알림설정을 상세히 조정할 수 있도록 함
이 데이터는 알림 설정 테이블에 보관하며 알림의 빈도를 제한하여 전송률을 제어하는 방법도 있다.

**재시도 방법**
제3자 서비스가 알림 전송에 실패하면, 해당 알림을 재시도 전융 큐에 발송 (Dead Letter Exchange)
같은 문제가 반복되면 개발자에서 통지

**큐 모니터링 및 이벤트 추적**
큐에 쌓인 알림의 데이터의 개수 및 쌓여있는 이벤트를 빠르게 소비하고 있는지 등 모니터링 할 수 있도록 함
알림 확인율, 클릭율 등 분석 서비스는 이벤트 추적 기능도 제공


## 11장. 뉴스 피드 시스템 설계
- - -


* 피드 발행: 사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스에 기록한다. 새 포스팅은 친구의 뉴스 피드에도 전송된다.
* 뉴스 피드 생성: 모든 친구의 포스팅을 시간 으흠 역순으로 모아서 만든다고 가정한다.

### 뉴스 피드 API
피드를 발행하고 뉴스 피드를 가져오거나, 친구를 추가하는 등 다양한 작업을 수행한다.

**피드 발행**

<img src="https://velog.velcdn.com/images/znzn9292/post/6699c693-7c23-4747-bc17-c94424db17fa/image.png" width="60%" height="30">

* 사용자: 모바일 앱이나 브라우저에서 새 포스팅을 올리는 주체, `POST /v1/me/feed` API를 이용
* 웹 서버: HTTP 요청을 내부 서비스로 중계하는 역할
* 포스팅 저장 서비스(Post Service): 새 포스팅을 데이터베스와 캐시에 저장
* 포스팅 전송 서비스(Fanout Service): 새 포스팅을 친구의 뉴스 피드에 푸시하고 데이터는 빠른 읽기를 위해 캐시에 보관
* 알림 서비스(Notification Service): 친구들에게 새 포스팅 알림 역할

**뉴스 피드 생성**

사용자가 보는 뉴스 피드가 어떻게 만들어질까?

<img src="https://velog.velcdn.com/images/znzn9292/post/f4b954ff-9c00-4a24-bb46-9c586d01753f/image.png" width="60%" height="30">

* 사용자: 뉴스 피드를 읽는 주체, `GET /v1/me/feed` API를 이용
* 웹 서버: 트래픽을 뉴스 피드 서비스로 전달
* 뉴스 피드 서비스(News Feed Service): 캐시에서 뉴스 피드를 가져오는 서비스
* 뉴스 피드 캐시(News Feed Cache): 뉴스 피드를 렌더링할 때 필요한 피드 ID를 보관

### 상세 설계

** 피드 발행 흐름 상세 설계 **
포스팅 전송 서비스(Fanout Service)이 핵심

<img src="https://velog.velcdn.com/images/znzn9292/post/3526b714-2aac-41cd-823d-2cfe0a78d604/image.png" width="60%" height="30">

* 웹 서버: 인증, 처리율 제한 등의 기능을 수행하고 스팸을 막고 유해한 콘텐츠가 자주 올라오는 것을 방지하기 위해 특정 기간 동안 한 사용자가 올릴 수 있는 포스팅의 수에 제한을 둠
* 포스틴 전송 서비스(Fanout Service): 특정 사용자의 새 포스팅을 사용자와 친구관계에 있는 모든 사용자에게 전달하는 과정
> **쓰기 시점에 팬아웃 하는 모델(PUSH 모델)**: 새로운 포스팅을 기록하는 시점에 뉴스 피드를 갱신, 포스팅이 완료되면 바로 해당 사용자 캐시에 해당 포스팅을 기록
>
> **읽기 시점에 팬아웃 하는 모델(PULL 모델)**: 피드를 읽어야 하는 시점에 뉴스 피드를 갱신, 사용자가 페이지를 로딩하는 시점에 새로운 포스트를 가져옴

**팬 아웃 서비스 동작(Fanout Service)**
1. 그래프 데이터베이스에서 친구 ID 목록을 가져온다. (그래프 데이터베이스는 친구 관계나 친구 추천을 관리하기 적합)
2. 사용자 정보 캐시에서 친구들의 정보를 가져와 설정 데이터를 필터한다.
3. 친구 목록과 새 스토리의 포스팅 ID를 메세지 큐에 넣는다.
4. 팬아웃 작업 서버가 메세지 큐에서 데이터를 꺼내 뉴스 피드 캐시에 넣는다.
   뉴스 피드 캐시에 데이터는 `<포스팅ID, 사용자ID>` 의 순서 쌍을 보관하는 매핑 테이블이다.
   메모리 요구량이 지나치게 늘어날 수 있기 때문에 사용자와 포스팅 전체 정보는 저장하지 않는다.

** 피드 읽기 흐름 상세 설계 **

<img src="https://velog.velcdn.com/images/znzn9292/post/8ccb4a10-a5cf-4c43-b7c1-8aa838b950b0/image.png" width="60%" height="30">

* 사용자가 뉴스 피드 조회 요청을 전송
* 웹 서버는 피드를 가져오기 위해 뉴스 피드 서비스를 호출
* 뉴스 피드 서비스는 뉴스 피드 캐시에서 포스팅 ID 목록을 가져옴
* 뉴스 피드에 표시할 사용자 이름, 사진, 콘텐츠, 이미지 등을 사용자 캐시와 포스팅 캐시에서 가져옴
* 생선된 뉴스 피드를 클라이언트에게 보내어 렌더링함

참고)
와디즈 - 그래프 데이터베이스 블로그
https://blog.wadiz.kr/%EA%B7%B8%EB%9E%98%ED%94%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%A1%9C-%EC%B9%9C%EA%B5%AC-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0/


## 12장. 채팅 시스템 설계
- - -

채팅 서비스는 사람들에 따라 떠올리는 것이 제각각이다. 그러므로 요구사항을 확실하게 알아두어야 한다.

### 개략적 설계안

채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용하여 서비스에 접속한다.
따라서 채팅 서비스의 경우 어떤 통신 프로트콜을 사용할 것인가도 중요한 문제다.

송신 클라이언트는 수신 클라이언트에게 전달할 메세지를 채팅 서비스에 보낼 때 HTTP 프로토콜을 사용한다.
* 클라이언트와 서버 사이의 연결을 끊지 않고 계속 유지할 수 있도록 `keep-alive` 헤더를 사용하여 TCP 접속 과정에 발생하는 핸드셰이크 횟수를 줄임
* 대중적인 채팅 프로그램이 초기에 HTTP를 사용

하지만, HTTP 프로토콜은 서버에서 클라이언트로 임의 시점에 메세지를 보내는 데는 쉽게 쓰일 수 없다.
서버가 연결을 만드는 것처럼 동작할 수 있도록 나온 기법에는 **폴링(Polling), 롱 폴링(Long Polling), 웹소켓(Web Socket)** 등이 있다.

**폴링**
폴링은 클라이언트가 주기적으로 서버에게 새 메세지가 있는지 물어보는 방법이다.
폴링 비용은 자주하면 할수록 올라가 전달할 메세지가 없는 경우에 서버 자원이 낭비된다.

<img src="https://velog.velcdn.com/images/znzn9292/post/0ac727e9-8905-4f36-a206-aa52a698e0e6/image.png" width="60%" height="30">


**롱 폴링**
폴링의 비효율적인 부분을 보완한 기법이다. 클라이언트는 새 메세지가 반환되거나 타임아웃 될 떄까지 연결을 유지하다 새 메세지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.

<img src="https://velog.velcdn.com/images/znzn9292/post/886c4370-f345-416b-81b6-6dbab1422f01/image.png" width="60%" height="30">

* 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우 메세지를 받는 서버는 해당 메세지를 수신할 클라이언트와 롱 폴링 연결을 가지고 있지 않을 수 있다.
* 서버 입장에서 클라이언트가 연결을 해제했는지 사실을 알 좋은 방법이 없다.
* 메세지를 많이 받지 않는 클라이언트도 주기적으로 서버에 다시 접속하므로 비효율적이다.

**웹소켓**
서버가 클라이언트에게 비동기(Async) 메세지를 보낼 때 가장 널리 상요하는 기술이다.

<img src="https://velog.velcdn.com/images/znzn9292/post/68778d43-77f5-457e-8308-cc4a016e709c/image.png" width="60%" height="30">

* 클라이언트에서 웹소켓 연결을 맺으면 항구적이며 양방향
* 처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드
* 80이나 443 기본 포트번호를 쓰기 때문에 방화벽이 있는 환경에서 잘 동작

웹소켓을 이용하면 메시지를 보낼 때나 받을 떄 동일한 프로토콜을 사용할 수 있으므로 설계, 구현도 단순하고 직관적이다.
유의할 것은 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 연결 관리를 효율적으로 해야한다.

<img src="https://velog.velcdn.com/images/znzn9292/post/a48333fc-a24c-4d73-a83c-172963feba22/image.png" width="60%" height="30">

* 채팅 서버는 클라이언트 사이에 메세지를 중계하는 역할
* 접속상태 서버는 사용자의 접속 여부를 관리
* 알림 서버는 푸시 알림 발송을 담당
* 키-값 저장소(Key-Value Store)에는 채팅 이력을 보관, 이전채팅을 전부 관리

**저장소**
데이터 계층에서 관계형 데이터베이스를 쓸 것이냐? 아니면 NoSQL을 채택할 것인가? 에 올바른 답을 하기 위해 중요하게 따져야 할 것은 데이터의 유형과 읽기/쓰기 연산의 패턴이다.
채팅 시스템이 다루는 데이터는 보통 두 가지다.
* 사용자 프로파일, 설정, 친구 목록처럼 일반적인 데이터는 안정성을 보장하는 관계형 데이터베이스에 보관
* 채팅 시스템에 고유한 데이터를 보관하는 결정은 읽기/쓰기 연산 패턴을 이해

여러 요구사항을 지원할 데이터베이스를 고르는 것은 아주 중요하다.
키-값 저장소를 추천하는 이유는 다음과 같다.

* 키-값 저장소는 수평적 규모확장이 쉽다.
* 데이터 접근 지연시간이 낮다.
* 관계형 데이터베이스는 인덱스가 커지면 데이터에 대한 무작위 접근을 처리하는 비용이 늘어난다.
* 이미 많은 안정적인 채팅 시스템이 키-값 저장소를 채택하고 있다. (페이스북-HBase, 디스코드-카산드라)

**데이터 모델 - 1:1 채팅을 위한 메세지 테이블**

<img src="https://velog.velcdn.com/images/znzn9292/post/4d05fec7-4f25-4963-90e5-8c703f372028/image.png" width="60%" height="30">

* 기본 키는 `MESSAGE_ID`로, 메세지 순서를 쉽게 정할 수 있도록 하는 역할도 담당

**데이터 모델 - 그룹 채팅을 위한 메세지 테이블**

<img src="https://velog.velcdn.com/images/znzn9292/post/484c4431-5ccc-4669-9892-04f397098408/image.png" width="60%" height="30">

* `CHANNEL_ID`, `MESSAGE_ID` 의 복합 키를 기본 키로 사용








